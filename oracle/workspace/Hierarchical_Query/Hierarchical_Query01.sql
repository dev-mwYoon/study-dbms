/*
   계층형 쿼리
   ㄴ 하나의 테이블 내에 레코드들이 계층관계(상위, 하위)를 이루며 존재하는 경우 데이터를 조회하기 위해 사용하는 쿼리를 의미
   ( 보통 부서 계층을 조회하기 위해 사용 )
   
   - 계층형 쿼리 실행 순서
	6	SELECT LPAD('-- -- -- -- ', 3*(LEVEL-1)) || DEPT_NAME AS DEPT_LEVEL, A.*
	1	FROM 테이블명 A
	5	WHERE 조건절
	2	START WITH DEPT_ID = '000000101'
	3	CONNECT BY PRIOR DEPT_ID = PAR_ID
	4	ORDER SIBLINGS BY DEPT_NAME;
	
 */

/*
 
 	▷ 예제 TABLE & VIEW
 	
 	CREATE TABLE V_EX_DEPT(
		DEPT_ID		CHAR(9) NOT NULL,
		DEPT_NAME 	VARCHAR2(200) NOT NULL,
		PAR_ID		CHAR(9) NOT NULL,
		SEQ			NUMBER(3,0) NOT NULL
	);
	
	COMMIT;
	
	INSERT INTO TBL_EX_DEPT
	(DEPT_ID, DEPT_NAME, PAR_ID, SEQ)
	SELECT '000000101','최상위부서','000000000',0
	FROM DUAL
	UNION ALL
	SELECT '000010000','테스트부서1','000000101',1
	FROM DUAL
	UNION ALL
	SELECT '000010001','테스트부서3','000000101',2
	FROM DUAL
	UNION ALL
	SELECT '000010200','테스트부서22','000010001',1
	FROM DUAL;
	
	COMMIT;
	
	SELECT DEPT_ID, DEPT_NAME, PAR_ID, SEQ FROM TBL_EX_DEPT; ( 아래는 조회 값 )
	000000101	최상위부서		000000000	0
	000010000	테스트부서1	000000101	1
	000010001	테스트부서3	000000101	2
	000010200	테스트부서22	000010001	1

	CREATE VIEW V_EX_DEPT AS
	 SELECT PAR_ID, DEPT_ID, DEPT_NAME, 
		SUBSTR(SYS_CONNECT_BY_PATH(DEPT_NAME, '|'),2) FULLNAME,
		SUBSTR(SYS_CONNECT_BY_PATH(DEPT_ID, '|'),2) FULLID, 
		SEQ
	FROM
	( 
		SELECT DEPT_ID, DEPT_NAME, PAR_ID, SEQ 
		FROM TBL_EX_DEPT
	)
	START WITH DEPT_ID = '000000101' CONNECT BY PRIOR DEPT_ID = PAR_ID
	ORDER SIBLINGS BY PAR_ID, SEQ;
	
	COMMIT;
 
 */


-- LPAD ( 좌측에 공백 또는 지정 문자열 채우기 / RPAD는 우측에 채우기 )
SELECT LPAD('-- -- -- -- ', 3*(LEVEL-1)) || DEPT_NAME AS DEPT_LEVEL, A.*
FROM V_EX_DEPT A
--START WITH DEPT_ID IS NOT NULL
START WITH DEPT_ID = '000000101'
CONNECT BY PRIOR DEPT_ID = PAR_ID;

-- CONNECT_BY_ROOT ( 최상위 노드 조회 )
SELECT CONNECT_BY_ROOT DEPT_ID AS DEPT_ID_ROOT, CONNECT_BY_ROOT (DEPT_NAME) AS DEPT_NAME_ROOT, LPAD('-- -- -- -- ', 3*(LEVEL-1)) || DEPT_NAME AS DEPT_LEVEL, A.*
FROM V_EX_DEPT A
START WITH DEPT_ID = '000000101'
CONNECT BY PRIOR DEPT_ID = PAR_ID;


-- ① PRIOR 자식 = 부모
-- ㄴ 부모 -> 자식 순으로 순방향 전개
SELECT LPAD('-- -- -- -- ', 3*(LEVEL-1)) || DEPT_NAME AS DEPT_LEVEL, A.*
FROM V_EX_DEPT A
START WITH DEPT_ID = '000000101'
CONNECT BY PRIOR DEPT_ID = PAR_ID;

--② PRIROR 부모 = 자식
--ㄴ 자식 -> 부모 순으로 역방향 전개
SELECT LPAD('-- -- -- -- ', 3*(LEVEL-1)) || DEPT_NAME AS DEPT_LEVEL, A.*
FROM V_EX_DEPT A
--START WITH DEPT_ID IS NOT NULL
START WITH DEPT_ID = '000000101'
CONNECT BY PRIOR PAR_ID = DEPT_ID;

--③ NOCYCLE
--ㄴ 동일 사이클 미전개
SELECT LPAD('-- -- -- -- ', 3*(LEVEL-1)) || DEPT_NAME AS DEPT_LEVEL, A.*
FROM V_EX_DEPT A
START WITH DEPT_ID = '000000101'
CONNECT BY NOCYCLE PRIOR DEPT_ID = PAR_ID;


-- ORDER SIBLINGS BY 컬럼명			형제 노드(동일한 LEVEL) 사이에서 정렬
SELECT LPAD('-- -- -- -- ', 3*(LEVEL-1)) || DEPT_NAME AS DEPT_LEVEL, A.*
FROM V_EX_DEPT A
START WITH DEPT_ID = '000000101'
CONNECT BY PRIOR DEPT_ID = PAR_ID
ORDER SIBLINGS BY DEPT_NAME;



-- 속한 부서의 상위 부서 조회 
SELECT LPAD('-- -- -- -- ', 3*(LEVEL-1)) || DEPT_NAME AS DEPT_LEVEL, A.*
FROM V_EX_DEPT A
START WITH DEPT_ID = '000010000' -- 나의 부서
CONNECT BY NOCYCLE PRIOR PAR_ID = DEPT_ID;

-- 속한 부서의 하위 부서 조회 
SELECT LPAD('-- -- -- -- ', 3*(LEVEL-1)) || DEPT_NAME AS DEPT_LEVEL, A.*
FROM V_EX_DEPT A
START WITH DEPT_ID = '000010001' -- 나의 부서
CONNECT BY PRIOR DEPT_ID = PAR_ID;

-- 같은 계층의 부서 및 하위 부서까지 조회
SELECT LPAD('-- -- -- -- ', 3*(LEVEL-1)) || DEPT_NAME AS DEPT_LEVEL, A.*
FROM V_EX_DEPT A
START WITH PAR_ID = '000000101' -- 나의 부모 부서를 기준으로 정렬
CONNECT BY PRIOR DEPT_ID = PAR_ID -- 부모 자식 순 정렬
ORDER SIBLINGS BY DEPT_NAME; -- 같은 계층일 경우 부서 이름으로 정렬






